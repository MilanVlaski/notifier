- [x] Make into multimodule
- [x] Add .editorconfig
- [x] Add checkstyle
- [x] Test coverage
- [x] Gradle dependencies check
- [x] Create build script
- [x] Make email configuration in `application.properties`
- [ ] Broker takes List of dependencies, creates a map out of it.
- [ ] The Broker @Bean will receive a List<ForSendingNotification>
- [ ] The Broker also depends on a NotificationSender(THING), which takes a lambda of the 
- [ ] The ForSendingNotifications takes a Notification as part of it's interface.
- [ ] No longer need an enum, though, we can just use instanceof based on the Notification.
- [ ] Use the Map<? extends Notification, NotificationSender> in Broker.
- In the end, it's enough to create a ForSendingNotifications, and define the Notification that it uses. Spring Boot can pick it up, and voila! There will even be tests for it!
- [ ] Recreate cloud env
- [ ] ^Add Spring health check
- [ ] Create deploy script
- [ ] ^With health check/smoke test
- [ ] Security later.
  - [ ] Quick refresher on what the code *could* look like for JWT 
  - [ ] JWT
  - [ ] GCloud IAM
- [ ] A nice convention for spring boot is, for each bean that you need in production, and that relies on some lower level protocol that can't be ran "raw" or locally, you want to create a "NoOp" bean, because it will allow the app to somehow execute, even if the dependency is not there. A good side effect of that is that you can have property files which are separate. You can also have your app be runnable locally, without any need for hacking. 
